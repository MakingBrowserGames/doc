# Game Walk-Through

*Whack That Mole!* is a basic, non-trivial, game built using
the Game Closure SDK. The [source code](https://github.com/gameclosure/whack-that-mole)
for the game is available to download and run, and we'll be
walking through the source code to see how things are put together.


## Install

First, make sure the
[Game Closure SDK](../guide/getting-started.html) is
installed and ready to go.

Download the game project by cloning the git repository:

~~~
$ git clone git@github.com:gameclosure/whack-that-mole.git
~~~

You'll need to register the project with basil before you
can run it in the browser, you should only need to do this once:

~~~
$ cd whack-that-mole
$ basil register
~~~

With the game registered, you're ready to play! You just
need to run the basil project server:

~~~
$ basil serve
~~~

Now, with the server running, navigate your web browser to
`http://localhost:9200` and you'll be greeted with the
following screen:

<img src="./assets/game-walkthrough/basil-start.png" alt="basil start screenshot" class="screenshot">

Navigate to the **Projects** section, and select the **Whack-that-Mole!** game:

<img src="./assets/game-walkthrough/basil-projects.png" alt="basil project select screenshot" class="screenshot">

Then click the big **Simulate** button to launch the game in
a new web browser tab.

<img src="./assets/game-walkthrough/game-title.png" alt="game title screenshot" class="screenshot">

Click the **Play** button on the title screen and off you go!


## Browser Debugging

* UI Inspector

<img src="./assets/game-walkthrough/ui-inspector.png" alt="ui inspector screenshot" class="screenshot">

* browser console

<img src="./assets/game-walkthrough/game-console.png" alt="browser console screenshot" class="screenshot">


## Project Structure

A game created for the Game Closure SDK has a basic file
structure which can be seen here:

~~~
.
├── manifest.json
├── sdk -> /path/to/basil/sdk
├── resources/
└── src
	└── Application.js
~~~

In the project directory there is a `manifest.json` file,
which contains a number of project configuration options, a
`src` directory, containing our application code, and a
`resources` directory, which is where the game assets are stored.

The game's manifest can contain any number of project
specific configuration options in JSON format. A typical,
minimal, `manifest.json` file contains a generated
application ID hash, a name, and perhaps the orientation of
the game. This file is usually generated by basil, but you
can edit it by hand, for example, this might be used for our
game's manifest:

~~~
{
  "appID": "abcdefghijklmnopqrstuvwxyz012345",
  "shortName": "whackthatmole",
  "title": "Whack-that-Mole!",
  "supportedOrientations": [
    "portrait"
  ]
}
~~~

You can find a complete list of [manifest options](../guide/manifest.html)
in the documentation.

There is a `sdk` directory which is actually a symlink to
the SDK installed with basil. This is provided as a
convenience for navigating the SDK JavaScript code to
see what's going on "under the hood".

A `resources` directory provides a place to store game
assets, like images and sound files.

The JavaScript code we'll develop our game with is put in
the `src` directory. The entry point for the game is
the `./src/Application.js` file, this defines an object that
inherits from the `GC.Application` class, and has a number
of options which you can read about in its [API documentation](../api/appengine.html).


## Game Flow

Before diving into a specific implementation, we'll first
take a top-down look at the application flow of the
*Whack-that-Mole!* game to get an idea how the pieces fit together.

<img src="./assets/game-walkthrough/game-flow.png" alt="game flow screenshot" class="screenshot">

First, the Game Closure SDK is initialized and the
environment is set up for the user's application. The entry
point for the game is the `./src/Application.js` file in the
project's directory. This file initializes our game screens
and manages events for moving between them.

The application uses a *stack* for pushing on---and popping
off---screens in the game. Once the game has started, the
title screen is pushed on to the stack; this displays the
artwork and awaits user input to begin the game. This screen
is defined in the `./src/TitleScreen.js` file.

When the user taps the play button, the game screen is then
pushed on to our screen stack. This screen is responsible for
setting up the game assets and interface, then starting,
playing, and ending the game. This is defined in the
`./src/GameScreen.js` file.

When the game ends, the user's score is displayed and the
game screen holds while we await user input continue. Upon
receiving that tap, the game screen is popped off
the screen stack, revealing our title screen which is now at
the top of the stack. The game returns to the title screen
and, as before, awaits to be played again.


## Game Structure

### Class System

In order to structure our JavaScript into modules and
classes, and to separate the files, we use a module system
for imports and classes. You can read about the
[usage of this system](../api/utilities.html#import)
in more detail in the documentation.

### Application.js

* GC.Application
* initUI / launchUI
* views
* GC.app.view (this.view) / StackView
* events

Once the Game Closure SDK environment is initialized, the
game picks up in your project's `./src/Application.js`
file. In *Whack-that-Mole!*, this file is rather short, it's
purpose is to initialize the title and game screen, and
handle events for directing the game flow.

~~~
import src.TitleScreen as TitleScreen;
import src.GameScreen as GameScreen;
import src.soundcontroller as soundcontroller;

exports = Class(GC.Application, function () {
  this.initUI = function () {
    // initialize game screens
    var titlescreen = new TitleScreen(),
		gamescreen = new GameScreen();
	
	// add to screen stack
	this.view.push(titlescreen);

	var sound = soundcontroller.getSound();

	// set up event handlers
	titlescreen.on('titlescreen:start', function () {
	  sound.play('levelmusic');
	  GC.app.view.push(gamescreen);
	  gamescreen.emit('app:start');
	});
		
	gamescreen.on('gamescreen:end', function () {
	  sound.stop('levelmusic');
	  GC.app.view.pop();
	});
  };

  this.launchUI = function () {};
});
~~~

At the top of this file, we import three additional source
files in our project's root directory using the `import`
command which is [defined](../api/utilities.html#import) in
the Game Closure SDK:

~~~
import src.TitleScreen as TitleScreen;
import src.GameScreen as GameScreen;
import src.soundcontroller as soundcontroller;
~~~

These files have been written as modules and are assigned to
variables within this file.

Note that this `Application.js` file is also a module, it's
a class that inherits from `GC.Application` using the
`Class` function, the new constructor which is assigned to
the `exports` object. This is a predefined object within
each module file, and what is returned when another file
imports this one. When our application it's instantiated, it's
assigned to the global property `GC.app`, which can be
accessed anywhere in your game code. Since you are only
going to have one application in your game, you can just
think of this as a singleton. Within the application's class
definition function, you can refer to it using the `this`
object. A bare-bones, working, `Application.js` file can
look like this:

~~~
exports = Class(GC.Application, function () {
  // class definition goes here ...
  // this === GC.app //=> true
});
~~~

The `GC.Application` class is special in that it has two
callback functions, `initUI` and `launchUI`, that it checks
for and runs when ready; this is where we'll hook in our
main game code. The `initUI` function is run after the Game
Closure engine is created and the scene graph is
ready. When the `launchUI` function is called, the splash
screen is removed, if there is one.

We're only using the `initUI` function in this game, we'll
run through that.

After our game screen classes have been imported at the top
of our file, we instantiate them once our game engine is ready:

~~~
var titlescreen = new TitleScreen(),
    gamescreen = new GameScreen();
~~~

We'll look in detail about how these screens are constructed
in the next couple of sections.

When the scene graph for the game engine is created, its
root node is stored at `GC.app.view`. Any View that is
attached as a child to this node, or its descendants, can be
rendered to the screen. The root view is a little special
because it's an instance of
[ui.StackView](../api/ui-stackview.html), which is a
*subclass* of [ui.View](../api/ui-view.html). It has
additional functionality for pushing and popping child views
and transitioning between them.

With our screens built, we push the title screen on to the
root view stack, and because of it's setup and dimensions,
is all that we see in the application:

~~~
this.view.push(titlescreen);
~~~

In the event handling code, we listen for the game start and
end events on our two screens and manage our root `StackView`:

~~~
titlescreen.on('titlescreen:start', function () {
  //...
  GC.app.view.push(gamescreen);
  gamescreen.emit('app:start');
});

gamescreen.on('gamescreen:end', function () {
  //...
  GC.app.view.pop();
});
~~~

When we receive the event to start the game, we *push* the
game screen on to the root stack. There is no need to remove
the title screen already in the stack, the game screen is
simply "on top" of it and becomes the visible view of the
application. By default, pushing another view to the
`StackView` has a side-scrolling animation transition, this
can be turned off.

The sound code is simple, but we'll look at that at towards
the end of this guide. The `soundcontroller` module returns
a `Sound` object singleton, which we use to play the level
music when we transition to the game screen.


### TitleScreen

* device
* ui.View / ui.ImageView
* class structure
	* inheritance
	* init -- opts, merge, supr
	* buildView
	* child views

### GameScreen

* child view set up
	* scoreboard
	* mole hills
	* game start flow
	* using animate
	* tick
	* end game flow

### MoleHill

* image resources
* child hierarchy setup
	* stack images
	* clipping
	* input
* advanced animate

### Sound
